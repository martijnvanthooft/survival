if (length(dropterms)) {
Terms2 <- Terms[ -dropterms]
X <- model.matrix(Terms2, mf, constrasts=contrast.arg)
# we want to number the terms wrt the original model matrix
temp <- attr(X, "assign")
shift <- sort(dropterms)
temp <- temp + 1*(shift[1] <= temp)
if (length(shift)==2) temp + 1*(shift[2] <= temp)
attr(X, "assign") <- temp
}
else X <- model.matrix(Terms, mf, contrasts=contrast.arg)
# drop the intercept after the fact, and also drop strata if necessary
Xatt <- attributes(X)
if (hasinteractions) adrop <- c(0, untangle.specials(Terms, "strata")$terms)
else adrop <- 0
xdrop <- Xatt$assign %in% adrop  #columns to drop (always the intercept)
X <- X[, !xdrop, drop=FALSE]
attr(X, "assign") <- Xatt$assign[!xdrop]
attr(X, "contrasts") <- Xatt$contrasts
offset <- model.offset(mf)
if (is.null(offset) | all(offset==0)) offset <- rep(0., nrow(mf))
else if (any(!is.finite(offset) | !is.finite(exp(offset))))
stop("offsets must lead to a finite risk score")
weights <- model.weights(mf)
if (!is.null(weights) && any(!is.finite(weights)))
stop("weights must be finite")
assign <- attrassign(X, Terms)
contr.save <- attr(X, "contrasts")
if (sum(Y[, ncol(Y)]) == 0) {
# No events in the data!
ncoef <- ncol(X)
ctemp <- rep(NA, ncoef)
names(ctemp) <- colnames(X)
concordance= c(concordant=0, discordant=0, tied.x=0, tied.y=0, tied.xy=0,
concordance=NA, std=NA, timefix=FALSE)
rval <- list(coefficients= ctemp,
var = matrix(0.0, ncoef, ncoef),
loglik=c(0,0),
score =0,
iter =0,
linear.predictors = offset,
residuals = rep(0.0, data.n),
means = colMeans(X), method=method,
n = data.n, nevent=0, terms=Terms, assign=assign,
concordance=concordance,  wald.test=0.0,
y = Y, call=Call)
class(rval) <- "coxph"
return(rval)
}
if (multi) {
cmap <- parsecovar3(tmap, colnames(X), attr(X, "assign"))
xstack <- stacker(cmap, as.integer(istate), X, Y, strata=istrat,
states=states)
X <- xstack$X
Y <- xstack$Y
istrat <- xstack$strata
if (length(offset)) offset <- offset[xstack$rindex]
if (length(weights)) weights <- weights[xstack$rindex]
if (length(cluster)) cluster <- cluster[xstack$rindex]
t2 <- tmap[-1,,drop=FALSE]   # remove the intercept row
r2 <- row(t2)[!duplicated(as.vector(t2))]
c2 <- col(t2)[!duplicated(as.vector(t2))]
a2 <- lapply(seq(along=r2), function(i) {cmap[1+assign[[r2[i]]], c2[i]]})
# which elements are unique?
tab <- table(r2)
count <- tab[r2]
names(a2) <- ifelse(count==1, row.names(t2)[r2],
paste(row.names(t2)[r2], colnames(cmap)[c2], sep="_"))
assign <- a2
}
# infinite covariates are not screened out by the na.omit routines
#  But this needs to be done after the multi-X part
if (!all(is.finite(X)))
stop("data contains an infinite predictor")
# init is checked after the final X matrix has been made
if (missing(init)) init <- NULL
else {
if (length(init) != ncol(X)) stop("wrong length for init argument")
temp <- X %*% init - sum(colMeans(X) * init) + offset
# it's okay to have a few underflows, but if all of them are too
#   small we get all zeros
if (any(exp(temp) > .Machine$double.xmax) || all(exp(temp)==0))
stop("initial values lead to overflow or underflow of the exp function")
}
pterms <- sapply(mf, inherits, 'coxph.penalty')
if (any(pterms)) {
pattr <- lapply(mf[pterms], attributes)
pname <- names(pterms)[pterms]
#
# Check the order of any penalty terms
ord <- attr(Terms, "order")[match(pname, attr(Terms, 'term.labels'))]
if (any(ord>1)) stop ('Penalty terms cannot be in an interaction')
pcols <- assign[match(pname, names(assign))]
fit <- coxpenal.fit(X, Y, istrat, offset, init=init,
control,
weights=weights, method=method,
row.names(mf), pcols, pattr, assign)
}
else {
if( method=="breslow" || method =="efron") {
if (grepl('right', type))  fitter <- get("coxph.fit")
else                 fitter <- get("agreg.fit")
}
else if (method=='exact') {
if (type== "right")  fitter <- get("coxexact.fit")
else  fitter <- get("agexact.fit")
}
else stop(paste ("Unknown method", method))
fit <- fitter(X, Y, istrat, offset, init, control, weights=weights, exposure=exposure,
method=method, row.names(mf))
}
if (is.character(fit)) {
fit <- list(fail=fit)
class(fit) <- 'coxph'
}
else {
if (!is.null(fit$coefficients) && any(is.na(fit$coefficients))) {
vars <- (1:length(fit$coefficients))[is.na(fit$coefficients)]
msg <-paste("X matrix deemed to be singular; variable",
paste(vars, collapse=" "))
if (!singular.ok) stop(msg)
# else warning(msg)  # stop being chatty
}
fit$n <- data.n
fit$nevent <- sum(Y[,ncol(Y)])
fit$terms <- Terms
fit$assign <- assign
class(fit) <- fit$class
fit$class <- NULL
# don't compute a robust variance if there are no coefficients
if (robust && !is.null(fit$coefficients) && !all(is.na(fit$coefficients))) {
fit$naive.var <- fit$var
# a little sneaky here: by calling resid before adding the
#   na.action method, I avoid having missings re-inserted
# I also make sure that it doesn't have to reconstruct X and Y
fit2 <- c(fit, list(x=X, y=Y, weights=weights))
if (length(istrat)) fit2$strata <- istrat
if (length(cluster)) {
temp <- residuals.coxph(fit2, type='dfbeta', collapse=cluster,
weighted=TRUE)
# get score for null model
if (is.null(init))
fit2$linear.predictors <- 0*fit$linear.predictors
else fit2$linear.predictors <- c(X %*% init)
temp0 <- residuals.coxph(fit2, type='score', collapse=cluster,
weighted=TRUE)
}
else {
temp <- residuals.coxph(fit2, type='dfbeta', weighted=TRUE)
fit2$linear.predictors <- 0*fit$linear.predictors
temp0 <- residuals.coxph(fit2, type='score', weighted=TRUE)
}
fit$var <- t(temp) %*% temp
u <- apply(as.matrix(temp0), 2, sum)
fit$rscore <- coxph.wtest(t(temp0)%*%temp0, u, control$toler.chol)$test
}
#Wald test
if (length(fit$coefficients) && is.null(fit$wald.test)) {
#not for intercept only models, or if test is already done
nabeta <- !is.na(fit$coefficients)
# The init vector might be longer than the betas, for a sparse term
if (is.null(init)) temp <- fit$coefficients[nabeta]
else temp <- (fit$coefficients -
init[1:length(fit$coefficients)])[nabeta]
fit$wald.test <-  coxph.wtest(fit$var[nabeta,nabeta], temp,
control$toler.chol)$test
}
# Concordance.  Done here so that we can use cluster if it is present
# The returned value is a subset of the full result, partly because it
#  is all we need, but more for backward compatability with survConcordance.fit
if (length(cluster))
temp <- concordancefit(Y, fit$linear.predictors, istrat, weights,
cluster=cluster, reverse=TRUE,
timefix= FALSE)
else temp <- concordancefit(Y, fit$linear.predictors, istrat, weights,
reverse=TRUE, timefix= FALSE)
if (is.matrix(temp$count))
fit$concordance <- c(colSums(temp$count), concordance=temp$concordance,
std=sqrt(temp$var))
else fit$concordance <- c(temp$count, concordance=temp$concordance,
std=sqrt(temp$var))
na.action <- attr(mf, "na.action")
if (length(na.action)) fit$na.action <- na.action
if (model) {
if (length(timetrans)) {
stop("'model=TRUE' not supported for models with tt terms")
}
fit$model <- mf
}
if (x)  {
fit$x <- X
if (length(timetrans)) fit$strata <- istrat
else if (length(strats)) fit$strata <- strata.keep
}
if (y)  fit$y <- Y
fit$timefix <- control$timefix  # remember this option
}
if (!is.null(weights) && any(weights!=1)) fit$weights <- weights
names(fit$means) <- names(fit$coefficients)
if (!is.null(exposure) && any(exposure!=1)) fit$exposure <- exposure
if (multi) {
fit$transitions <- transitions
fit$states <- states
fit$cmap <- cmap
fit$resid <- rowsum(fit$resid, xstack$rindex)
names(fit$coefficients) <- seq(along=fit$coefficients)
if (x) fit$strata <- istrat  # save the expanded strata
class(fit) <- c("coxphms", class(fit))
}
fit$formula <- formula(Terms)
if (length(xlevels) >0) fit$xlevels <- xlevels
fit$contrasts <- contr.save
if (any(offset !=0)) fit$offset <- offset
fit$call <- Call
fit
}
coxph.fit <- function(x, y, strata, offset, exposure, init, control,
weights, method, rownames, resid=TRUE)
{
n <-  nrow(y)
if (is.matrix(x)) nvar <- ncol(x)
else {
if (length(x)==0) nvar <-0
else nvar <-1
}
time <- y[,1]
status <- y[,2]
# Sort the data (or rather, get a list of sorted indices)
if (length(strata)==0) {
sorted <- order(time)
strata <- NULL
newstrat <- as.integer(rep(0,n))
}
else {
sorted <- order(strata, time)
strata <- strata[sorted]
newstrat <- as.integer(c(1*(diff(as.numeric(strata))!=0), 1))
}
if (missing(offset) || is.null(offset)) offset <- rep(0,n)
if (missing(weights)|| is.null(weights)) weights <- rep(1,n)
else {
if (any(weights<=0)) stop("Invalid weights, must be >0")
weights <- weights[sorted]
}
if (missing(exposure) || is.null(exposure)) exposure <- rep(1,n)
else {
if (any(exposure<=0)) stop("Invalid exposure, must be >0")
exposure <- exposure[sorted]
}
stime <- as.double(time[sorted])
sstat <- as.integer(status[sorted])
if (nvar==0) {
# A special case: Null model.
#  (This is why I need the rownames arg- can't use x' names)
# Set things up for 0 iterations on a dummy variable
x <- as.matrix(rep(1.0, n))
nullmodel <- TRUE
nvar <- 1
init <- 0
maxiter <- 0
}
else {
nullmodel <- FALSE
maxiter <- control$iter.max
if (!missing(init) && length(init)>0) {
if (length(init) != nvar) stop("Wrong length for inital values")
}
else init <- rep(0,nvar)
}
storage.mode(weights) <- storage.mode(init) <- "double"
coxfit <- .Call(Ccoxfit6,
as.integer(maxiter),
stime,
sstat,
x[sorted,],
as.double(offset[sorted]),
weights,
exposure,
newstrat,
as.integer(method=="efron"),
as.double(control$eps),
as.double(control$toler.chol),
as.vector(init),
as.integer(1))  # internally rescale
if (nullmodel) {
if (resid) {
score <- exp(offset[sorted])
coxres <- .C(Ccoxmart, as.integer(n),
as.integer(method=='efron'),
stime,
sstat,
newstrat,
as.double(score),
as.double(weights),
resid=double(n))
resid <- double(n)
resid[sorted] <- coxres$resid
names(resid) <- rownames
list(loglik = coxfit$loglik[1],
linear.predictors = offset,
residuals = resid,
method = method,
class = c('coxph.null', 'coxph') )
}
else list(loglik = coxfit$loglik[1],
linear.predictors = offset,
method = method,
class = c('coxph.null', 'coxph') )
}
else {
coef <- coxfit$coef
lp <- c(x %*% coef) + offset - sum(coef*coxfit$means)
var <- matrix(coxfit$imat,nvar,nvar)
if (coxfit$flag < nvar) which.sing <- diag(var)==0
else which.sing <- rep(FALSE,nvar)
infs <- abs(coxfit$u %*% var)
if (maxiter >1) {
if (coxfit$flag == 1000) {
warning("Ran out of iterations and did not converge")
if (max(lp) > 500 || any(!is.finite(infs)))
warning("one or more coefficients may be infinite")
}
else {
infs <- (!is.finite(coxfit$u) |
((infs > control$eps) &
infs > control$toler.inf*abs(coef)))
if (any(infs))
warning(paste("Loglik converged before variable ",
paste((1:nvar)[infs],collapse=","),
"; coefficient may be infinite. "))
}
}
names(coef) <- dimnames(x)[[2]]
if (maxiter > 0) coef[which.sing] <- NA  #leave it be if iter=0 is set
rval <- list(coefficients  = coef,
var    = var,
loglik = coxfit$loglik,
score  = coxfit$sctest,
iter   = coxfit$iter,
linear.predictors = as.vector(lp),
means = coxfit$means,
method = method,
class ='coxph')
if (resid) {
score <- exp(lp[sorted])
coxres <- .C(Ccoxmart, as.integer(n),
as.integer(method=='efron'),
stime,
sstat,
newstrat,
as.double(score),
as.double(weights),
resid=double(n))
resid <- double(n)
resid[sorted] <- coxres$resid
names(resid) <- rownames
# rval$residuals <- resid  # not good enough
# some other code expects the ORDER of components in a coxph
# object will never change: residuals right before means
rval <- c(rval[1:6], list(residuals=resid), rval[-(1:6)])
}
rval
}
}
coxph.fit <- function(x, y, strata, offset, exposure, init, control,
weights, method, rownames, resid=TRUE)
{
n <-  nrow(y)
if (is.matrix(x)) nvar <- ncol(x)
else {
if (length(x)==0) nvar <-0
else nvar <-1
}
time <- y[,1]
status <- y[,2]
# Sort the data (or rather, get a list of sorted indices)
if (length(strata)==0) {
sorted <- order(time)
strata <- NULL
newstrat <- as.integer(rep(0,n))
}
else {
sorted <- order(strata, time)
strata <- strata[sorted]
newstrat <- as.integer(c(1*(diff(as.numeric(strata))!=0), 1))
}
if (missing(offset) || is.null(offset)) offset <- rep(0,n)
if (missing(weights)|| is.null(weights)) weights <- rep(1,n)
else {
if (any(weights<=0)) stop("Invalid weights, must be >0")
weights <- weights[sorted]
}
if (missing(exposure) || is.null(exposure)) exposure <- rep(1,n)
else {
if (any(exposure<=0)) stop("Invalid exposure, must be >0")
exposure <- exposure[sorted]
}
stime <- as.double(time[sorted])
sstat <- as.integer(status[sorted])
if (nvar==0) {
# A special case: Null model.
#  (This is why I need the rownames arg- can't use x' names)
# Set things up for 0 iterations on a dummy variable
x <- as.matrix(rep(1.0, n))
nullmodel <- TRUE
nvar <- 1
init <- 0
maxiter <- 0
}
else {
nullmodel <- FALSE
maxiter <- control$iter.max
if (!missing(init) && length(init)>0) {
if (length(init) != nvar) stop("Wrong length for inital values")
}
else init <- rep(0,nvar)
}
storage.mode(weights) <- storage.mode(init) <- "double"
coxfit <- .Call(Ccoxfit6,
as.integer(maxiter),
stime,
sstat,
x[sorted,],
as.double(offset[sorted]),
weights,
exposure,
newstrat,
as.integer(method=="efron"),
as.double(control$eps),
as.double(control$toler.chol),
as.vector(init),
as.integer(1))  # internally rescale
if (nullmodel) {
if (resid) {
score <- exp(offset[sorted])
coxres <- .C(Ccoxmart, as.integer(n),
as.integer(method=='efron'),
stime,
sstat,
newstrat,
as.double(score),
as.double(weights),
resid=double(n))
resid <- double(n)
resid[sorted] <- coxres$resid
names(resid) <- rownames
list(loglik = coxfit$loglik[1],
linear.predictors = offset,
residuals = resid,
method = method,
class = c('coxph.null', 'coxph') )
}
else list(loglik = coxfit$loglik[1],
linear.predictors = offset,
method = method,
class = c('coxph.null', 'coxph') )
}
else {
coef <- coxfit$coef
lp <- c(x %*% coef) + offset - sum(coef*coxfit$means)
var <- matrix(coxfit$imat,nvar,nvar)
if (coxfit$flag < nvar) which.sing <- diag(var)==0
else which.sing <- rep(FALSE,nvar)
infs <- abs(coxfit$u %*% var)
if (maxiter >1) {
if (coxfit$flag == 1000) {
warning("Ran out of iterations and did not converge")
if (max(lp) > 500 || any(!is.finite(infs)))
warning("one or more coefficients may be infinite")
}
else {
infs <- (!is.finite(coxfit$u) |
((infs > control$eps) &
infs > control$toler.inf*abs(coef)))
if (any(infs))
warning(paste("Loglik converged before variable ",
paste((1:nvar)[infs],collapse=","),
"; coefficient may be infinite. "))
}
}
names(coef) <- dimnames(x)[[2]]
if (maxiter > 0) coef[which.sing] <- NA  #leave it be if iter=0 is set
rval <- list(coefficients  = coef,
var    = var,
loglik = coxfit$loglik,
score  = coxfit$sctest,
iter   = coxfit$iter,
linear.predictors = as.vector(lp),
means = coxfit$means,
method = method,
class ='coxph')
if (resid) {
score <- exp(lp[sorted])
coxres <- .C(Ccoxmart, as.integer(n),
as.integer(method=='efron'),
stime,
sstat,
newstrat,
as.double(score),
as.double(weights),
resid=double(n))
resid <- double(n)
resid[sorted] <- coxres$resid
names(resid) <- rownames
# rval$residuals <- resid  # not good enough
# some other code expects the ORDER of components in a coxph
# object will never change: residuals right before means
rval <- c(rval[1:6], list(residuals=resid), rval[-(1:6)])
}
rval
}
}
